<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   <meta name="description" content="如何用css制作下拉菜单">
    <meta name="author" content="<xuxx<hello@xuxinxin.com">
    <meta name="keywords" content="下拉菜单，css" />
    <link rel="shortcut icon" href="img/favicon.ico" />
    <title>徐鑫鑫的博客</title>

    <!-- Bootstrap core CSS -->
    <link href="dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="blog.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="blog-masthead">
      <div class="container">
        <nav class="blog-nav">
          <a class="blog-nav-item active" href="index.html">博客</a>
          <a class="blog-nav-item" href="blog2.html">关于我</a>
        </nav>
      </div>
    </div>
  <div class="container">

      <div class="row">

        <div class="col-sm-8 blog-main">

          <div class="blog-post">
            <br>
            <h2 class="blog-post-title">1、安装git</h2>
            <p class="blog-post-meta">2014-09-01</p>
            
           <div class="x-wiki-content x-content"><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
                   
                    <hr style="border-top-color:#ccc" />
                    
<p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p>
<h3 id="-linux-git">在Linux上安装Git</h3>
<p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p>
<pre><code>$ git
The program &#39;git&#39; is currently not installed. You can install it by typing:
sudo apt-get install git
</code></pre><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p>
<p><div class="html5-video" data-type="video" data-width="638" data-height="478" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-apt-install.mp4"></div></p>

<p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p>
<h3 id="-mac-os-x-git">在Mac OS X上安装Git</h3>
<p>如果你正在使用Mac做开发，有两种安装Git的方法。</p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/">http://brew.sh/</a>。</p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<p><img src="img/git1.jpg"alt="install-git-by-xcode"></p>
<p>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p>
<h3 id="-windows-git">在Windows上安装Git</h3>
<p>实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。</p>
<p>Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。</p>
<p>msysgit是Windows版的Git，从<a href="http://msysgit.github.io/">http://msysgit.github.io/</a>下载，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p><img src="img/git2.png" alt="install-git-on-windows"></p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<pre><code>$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;
</code></pre><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
</div><br><br>











<h2 class="blog-post-title">2、创建版本库</h2>

<div class="x-wiki-content x-content"><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<hr style="border-top-color:#ccc" />              
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
</code></pre><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p>
<p><span style="color:red">如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</span></p>
<p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<pre><code>$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-init.mp4"></div></p>

<p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p>
<h3 id="-">把文件添加到版本库</h3>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p><span style="color:red">使用Windows的童鞋要特别注意：</span></p>
<p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p>
<p><img src="img/git3.jpg" alt="set-utf8-notepad++"></p>
<p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<pre><code>$ git add readme.txt
</code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<pre><code>$ git commit -m &quot;wrote a readme file&quot;
[master (root-commit) cb926e7] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
</code></pre><p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/add-and-commit.mp4"></div></p>

<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p><code>git commit</code>命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt
$ git add file3.txt
$ git commit -m &quot;add 3 files.&quot;
</code></pre><h3 id="-">小结</h3>
<p>现在总结一下今天学的两点内容：</p>
<p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ul>
<li><p>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</p>
</li>
<li><p>第二步，使用命令<code>git commit</code>，完成。</p>
</li>
</ul>
</div><br><br>












<h2 class="blog-post-title">3、时光机穿梭</h2>
<div class="x-wiki-content x-content"><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<hr style="border-top-color:#ccc" />
                    
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre><p>现在，运行<code>git status</code>命令看看结果：</p>
<pre><code>$ git status
# On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#    modified:   readme.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用<code>git diff</code>这个命令看看：</p>
<pre><code>$ git diff readme.txt 
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is free software.
</code></pre><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。</p>
<p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>
<pre><code>$ git add readme.txt
</code></pre><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p>
<pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre><p><code>git status</code>告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：</p>
<pre><code>$ git commit -m &quot;add distributed&quot;
[master ea34578] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p>
<pre><code>$ git status
# On branch master
nothing to commit (working directory clean)
</code></pre><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-diff-status.mp4"></div></p>

<h3 id="-">小结</h3>
<ul>
<li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>
</li>
<li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>
</li>
</ul>
</div>






<h2 class="blog-post-title">4、版本回退</h2>
<div class="x-wiki-content x-content"><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<hr style="border-top-color:#ccc" />
                    
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre><p>然后尝试提交：</p>
<pre><code>$ git add readme.txt
$ git commit -m &quot;append GPL&quot;
[master 3628164] append GPL
1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre><p>版本2：add distributed</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre><p>版本3：append GPL</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p>
<pre><code>$ git log
commit 3628164fb26d48395383f8f31179f24e0882e1e0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Tue Aug 20 15:11:49 2013 +0800

    append GPL

commit ea34578d5496d7dd233c827ed32a8cd576c5ee85
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Tue Aug 20 14:53:12 2013 +0800 

    add distributed

commit cb926e7ea50ad11b8f9e909c05226233bf755030
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Mon Aug 19 17:51:55 2013 +0800 

    wrote a readme file
</code></pre><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是“append GPL”，上一次是“add distributed”，最早的一次是“wrote a readme file”。
如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 <code>--pretty=oneline</code>参数：</p>
<pre><code>$ git log --pretty=oneline
3628164fb26d48395383f8f31179f24e0882e1e0 append GPL
ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed
cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file
</code></pre><p>需要友情提示的是，你看到的一大串类似<code>3628164...882e1e0</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p>
<p><img src="img/git4.jpg" alt="git-log-timeline"></p>
<p>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>3628164...882e1e0</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用<code>git reset</code>命令：</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at ea34578 add distributed
</code></pre><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看readme.txt的内容是不是版本“add distributed”：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software.
</code></pre><p>果然。</p>
<p>还可以继续回退到上一个版本“wrote a readme file”，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p>
<pre><code>$ git log
commit ea34578d5496d7dd233c827ed32a8cd576c5ee85
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Tue Aug 20 14:53:12 2013 +0800

    add distributed

commit cb926e7ea50ad11b8f9e909c05226233bf755030
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Mon Aug 19 17:51:55 2013 +0800

    wrote a readme file
</code></pre><p>最新的那个版本“append GPL”已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个“append GPL”的<code>commit id</code>是<code>3628164...</code>，于是就可以指定回到未来的某个版本：</p>
<pre><code>$ git reset --hard 3628164
HEAD is now at 3628164 append GPL
</code></pre><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看readme.txt的内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre><p>果然，我胡汉山又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向“append GPL”：</p>
<p><img src="./img/git5.jpg" alt="git-head"></p>
<p>改为指向“add distributed”：</p>
<p><img src="img/git6.jpg" alt="git-head-move"></p>
<p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p>
<p><div class="html5-video" data-type="video" data-width="400" data-height="300" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reset.mp4"></div></p>

<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到“add distributed”版本时，再想恢复到“append GPL”，就必须找到“append GPL”的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<pre><code>$ git reflog
ea34578 HEAD@{0}: reset: moving to HEAD^
3628164 HEAD@{1}: commit: append GPL
ea34578 HEAD@{2}: commit: add distributed
cb926e7 HEAD@{3}: commit (initial): wrote a readme file
</code></pre><p>终于舒了口气，第二行显示“append GPL”的commit id是<code>3628164</code>，现在，你又可以乘坐时光机回到未来了。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-reflog-reset.mp4"></div></p>

<h3 id="-">小结</h3>
<p>现在总结一下：</p>
<ul>
<li><p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p>
</li>
<li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ul>
</div><br><br>








<h2 class="blog-post-title">5、暂存区与工作区</h2>
 <div class="x-wiki-content x-content"><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>先来看名词解释。</p>
<hr style="border-top-color:#ccc" />
                   
<p><strong>工作区</strong>（Working Directory）：就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p>
<p><img src="./img/git9.jpg" alt="working-dir"></p>
<p><strong>版本库</strong>（Repository）：工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="./img/git10.jpg" alt="git-repo"></p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
<p>先用<code>git status</code>查看一下状态：</p>
<pre><code>$ git status
# On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       modified:   readme.txt
#
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#       LICENSE
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       new file:   LICENSE
#       modified:   readme.txt
#
</code></pre><p>现在，暂存区的状态就变成这样了：</p>
<p><img src="./img/git11.jpg" alt="git-stage"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<pre><code>$ git commit -m &quot;understand how stage works&quot;
[master 27c9860] understand how stage works
 2 files changed, 675 insertions(+)
 create mode 100644 LICENSE
</code></pre><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<pre><code>$ git status
# On branch master
nothing to commit (working directory clean)
</code></pre><p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="./img/git12.jpg" alt="git-stage-after-commit"></p>
<h3 id="-">小结</h3>
<p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
<p>没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。</p>
</div><br><br>












<h2 class="blog-post-title">5、管理修改</h2>
<div class="x-wiki-content x-content"><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>

<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
                    <hr style="border-top-color:#ccc" />
                    
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre><p>然后，添加：</p>
<pre><code>$ git add readme.txt
$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre><p>然后，再修改readme.txt：</p>
<pre><code>$ cat readme.txt 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre><p>提交：</p>
<pre><code>$ git commit -m &quot;git tracks changes&quot;
[master d4f25b6] git tracks changes
 1 file changed, 1 insertion(+)
</code></pre><p>提交后，再看看状态：</p>
<pre><code>$ git status
# On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       modified:   readme.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>咦，怎么第二次的修改没有被提交？</p>
<p>别激动，我们回顾一下操作过程：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>
<p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<pre><code>$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre><p>可见，第二次修改确实没有被提交。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-add-changes.mp4"></div></p>

<p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<h3 id="-">小结</h3>
<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不<code>add</code>到暂存区，那就不会加入到<code>commit</code>中。</p>
</div><br><br>













<h2 class="blog-post-title">6、撤销修改</h2>
<div class="x-wiki-content x-content"><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p>
<hr style="border-top-color:#ccc" />
                    
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.
</code></pre><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>
<pre><code>$ git status
# On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       modified:   readme.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<pre><code>$ git checkout -- readme.txt
</code></pre><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>现在，看看<code>readme.txt</code>的文件内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre><p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“创建一个新分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-working-dir.mp4"></div></p>

<p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

$ git add readme.txt
</code></pre><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>
<pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre><p>Git同样告诉我们，用命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<pre><code>$ git reset HEAD readme.txt
Unstaged changes after reset:
M       readme.txt
</code></pre><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p>
<pre><code>$ git status
# On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       modified:   readme.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>还记得如何丢弃工作区的修改吗？</p>
<pre><code>$ git checkout -- readme.txt

$ git status
# On branch master
nothing to commit (working directory clean)
</code></pre><p>整个世界终于清静了！</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/discard-changes-of-staged.mp4"></div></p>

<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<a href="/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000">版本回退</a>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……</p>
<h3 id="-">小结</h3>
<p>又到了小结时间。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000">版本回退</a>一节，不过前提是没有推送到远程库。</p>
</div><br><br>









<h2 class="blog-post-title">7、删除文件</h2>
<div class="x-wiki-content x-content"><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p>
 <hr style="border-top-color:#ccc" />
                    
<pre><code>$ git add test.txt
$ git commit -m &quot;add test.txt&quot;
[master 94cdc44] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
</code></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<pre><code>$ rm test.txt
</code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<pre><code>$ git status
# On branch master
# Changes not staged for commit:
#   (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       deleted:    test.txt
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<pre><code>$ git rm test.txt
rm &#39;test.txt&#39;
$ git commit -m &quot;remove test.txt&quot;
[master d17efd8] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre><p>现在，文件就从版本库中被删除了。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-rm.mp4"></div></p>

<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<pre><code>$ git checkout -- test.txt
</code></pre><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h3 id="-">小结</h3>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
</div><br><br>










<h2 class="blog-post-title">8、远程仓库</h2>
<div class="x-wiki-content x-content"><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p>
                    
<hr style="border-top-color:#ccc" />
                    
<p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
</code></pre><p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/ssh-keygen.mp4"></div></p>

<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>
<p><img src="./img/git13.jpg" alt="github-addkey-1"></p>
<p>点“Add Key”，你就应该看到已经添加的Key：</p>
<p><img src="./img/git14.jpg" alt="github-addkey-2"></p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<h3 id="-">小结</h3>
<p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p>
</div><br><br>











<h2 class="blog-post-title">9、添加远程库</h2>
 <div class="x-wiki-content x-content"><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<hr style="border-top-color:#ccc" />
                   
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>
<p><img src="img/git15.jpg" alt="github-create-repo-1"></p>
<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="img/git15.jpg" alt="github-create-repo-2"></p>
<p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>
<pre><code>$ git remote add origin git@github.com:michaelliao/learngit.git
</code></pre><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<pre><code>$ git push -u origin master
Counting objects: 19, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (19/19), done.
Writing objects: 100% (19/19), 13.73 KiB, done.
Total 23 (delta 6), reused 0 (delta 0)
To git@github.com:michaelliao/learngit.git
 * [new branch]      master -&gt; master
Branch master set up to track remote branch master from origin.
</code></pre><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-remote-add.mp4"></div></p>

<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>
<p><img src="img/git15.jpg" alt="github-repo"></p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<pre><code>$ git push origin master
</code></pre><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<h3 id="ssh-">SSH警告</h3>
<p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<pre><code>The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to continue connecting (yes/no)?
</code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<pre><code>Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.
</code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>
<h3 id="-">小结</h3>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
</div>












<h2 class="blog-post-title">10、从远程库克隆</h2>
<div class="x-wiki-content x-content"><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<hr style="border-top-color:#ccc" />
                  
<p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p>
<p><img src="./img/git19.jpg" alt="github-init-repo"></p>
<p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：</p>
<p><img src="./img/git20.jpg" alt="github-init-repo-2"></p>
<p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p>
<pre><code>$ git clone git@github.com:michaelliao/gitskills.git
Cloning into &#39;gitskills&#39;...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (3/3), done.

$ cd gitskills
$ ls
README.md
</code></pre><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了。</p>
<p><div class="html5-video" data-type="video" data-width="648" data-height="434" data-src="http://liaoxuefeng-liaoxuefeng.stor.sinaapp.com/learngit/video/git-clone.mp4"></div></p>

<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>
<h3 id="-">小结</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p>
</div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
    <script src="dist/js/bootstrap.min.js"></script>
    <script src="dist/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
